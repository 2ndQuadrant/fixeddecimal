FIXEDDECIMAL
============

FixedDecimal is a fixed precision decimal type which internally uses a 64bit
integer type for its underlying storage. This makes fixeddecimal very fast when
compared to PostgreSQL's NUMERIC type. Although fixeddecimal is unable to store
the same range of numbers that NUMERIC is able to.

As of today the precision of this type is "hard-coded" at compile time using
the FIXEDDECIMAL_PRECISION and FIXEDDECIMAL_MULTIPLIER pre-processor constants
in fixeddecimal.c.

By default the precision of fixeddecimal is 2 decimal digits after the decimal
point. This allows fixeddecimal to store a maximum value of 92233720368547758.07
and a minimum value of -92233720368547758.08. These numbers may look familiar,
as if you remove the decimal point the numbers represent the same limits as a
64 bit integer type on a two's complement machine.

Internally fixeddecimal stores the value as an integer where the actual value
stored is the fixeddecimal value * FIXEDDECIMAL_MULTIPLIER. By default this is
100, so a value of 1.00 will actually be stored as 100. It should also be noted
that all arithmetic on fixeddecimals uses integer arithmetic on the actual
stored integer value. This means that division truncates rather than rounds.

For example:

test=# select '2.00'::fixeddecimal / '3.00'::fixeddecimal;
 ?column? 
----------
 0.66
(1 row)

Where the same calculation done in PostgreSQL's NUMERIC type would result in a
number which ends with a '7' due to the infinity of 6's being rounded up to 7.

It should also be noted that multiplication and division using fixeddecimal
requires the use of a 128bit integer type. The reason for this is due to the
internal integer storage and also from danger of overflow.

If we imagine the following calculation in fixeddecimal: 2 * 2.5. Internally
this would be 200 * 250 (With a FIXEDDECIMAL_MULTIPLIER of 100). The result of
this is 50000, so we must now divide the number by FIXEDDECIMAL_MULTIPLIER in
order to obtain the expected internal value of 500. Such calculations may cause
a fixednumeric to overflow unnecessarily, so in order to avoid this problem
all division and multiplication uses a 128bit integer type. Addition and
subtraction do not suffer from the same problem.

It should also be noted that excess precision is ignored by fixeddecimal.
With a FIXEDDECIMAL_PRECISION of 2, any value after the 2nd digit following
the decimal point is completely ignored rather than rounded. The following
example demonstrates this:

test=# select '1.239'::fixeddecimal;
 fixeddecimal 
--------------
 1.23
(1 row)

It is especially important to remember that this truncation also occurs during
arithmetic. Notice in the following example the result is 1120 rather than
1129:

test=# select '1000'::fixeddecimal * '1.129'::fixeddecimal;
 ?column? 
----------
 1120.00
(1 row)



